<?php
declare(strict_types=1);

namespace Donatorsky\VendorCompress;

use Generator;
use InvalidArgumentException;
use Iterator;
use Phar;
use RecursiveCallbackFilterIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;

class VendorCompress {
	public const VERSION = '2.0.0';

	/**
	 * @var \Donatorsky\VendorCompress\Config
	 */
	private $config;

	/**
	 * @var string
	 */
	private $vendorDirectoryPath;

	/**
	 * @var string
	 */
	private $vendorPharPath;

	/**
	 * @param string                            $vendorDirectoryPath Path to vendor directory based on which PHAR file will be created
	 * @param string                            $vendorPharPath      Path in which vendor.phar file will be generated
	 * @param \Donatorsky\VendorCompress\Config $config              The configuration
	 */
	public function __construct(string $vendorDirectoryPath, string $vendorPharPath, Config $config) {
		if (!\is_dir($vendorDirectoryPath)) {
			throw new InvalidArgumentException(\sprintf('The path [%s] does not exist or is inaccessible.', $vendorDirectoryPath));
		}

		if (!\is_dir(\dirname($vendorPharPath))) {
			throw new InvalidArgumentException(\sprintf('The path for PHAR file [%s] does not exist or is inaccessible.', $vendorPharPath));
		}

		$this->vendorDirectoryPath = $vendorDirectoryPath;
		$this->vendorPharPath = $vendorPharPath;
		$this->config = $config;
	}

	/**
	 * @return \Phar
	 */
	public function create(): Phar {
		/**
		 * @var array<string, \PharFileInfo>&\Phar
		 */
		$phar = new Phar($this->vendorPharPath, Phar::KEY_AS_PATHNAME | Phar::CURRENT_AS_FILEINFO, $this->config->getAlias());

		$phar->startBuffering();

		$TStart = 0.0;
		$filesIterator = $this->getFilesIterator();
		$processedFilesIterator = $this->getProcessedFilesIterator($filesIterator);

		if ($this->config->isDebug()) {
			\printf(
				"\nusage = %.2f MiB, usage(true) = %.2f MiB, peak_usage(true) = %.2f MiB, peak_usage(true) = %.2f MiB\n",
				\memory_get_usage() / 1024 ** 2,
				\memory_get_usage(true) / 1024 ** 2,
				\memory_get_peak_usage() / 1024 ** 2,
				\memory_get_peak_usage(true) / 1024 ** 2
			);

			$TStart = \microtime(true);
			\iterator_to_array($filesIterator);
			\printf("getFilesIterator(): %.6f s\n", \microtime(true) - $TStart);
		}

		$tmpRootPath = \sys_get_temp_dir() . DIRECTORY_SEPARATOR . \uniqid('vendor', true) . DIRECTORY_SEPARATOR;

		if ($this->config->isDebug()) {
			$TStart = \microtime(true);
		}

		if (!\mkdir($tmpRootPath) && !\is_dir($tmpRootPath)) {
			throw new RuntimeException('Could not create temporary directory');
		}

		if ($this->config->isDebug()) {
			echo $tmpRootPath . PHP_EOL;
		}

		foreach ($processedFilesIterator as $relativePath => $content) {
			if (!\is_dir($dir = $tmpRootPath . \dirname($relativePath)) && !\mkdir($dir, 0777, true) && !\is_dir($dir)) {
				throw new RuntimeException('Could not create temporary directory');
			}

			\file_put_contents($tmpRootPath . $relativePath, $content);
		}

		if ($this->config->isDebug()) {
			\printf("generate files in tmp dir: %.6f s\n", \microtime(true) - $TStart);

			$TStart = \microtime(true);
		}

		$phar->buildFromDirectory($tmpRootPath);

		if ($this->config->isDebug()) {
			\printf("buildFromDirectory(): %.6f s\n", \microtime(true) - $TStart);
		}

		if (isset($phar['composer/autoload_classmap.php'])) {
			$this->updateBaseDir($phar, 'composer/autoload_classmap.php');
		}

		if (isset($phar['composer/autoload_files.php'])) {
			$this->updateBaseDir($phar, 'composer/autoload_files.php');
		}

		if (isset($phar['composer/autoload_namespaces.php'])) {
			$this->updateBaseDir($phar, 'composer/autoload_namespaces.php');
		}

		if (isset($phar['composer/autoload_psr4.php'])) {
			$this->updateBaseDir($phar, 'composer/autoload_psr4.php');
		}

		if (isset($phar['composer/autoload_static.php'])) {
			$content = \file_get_contents($phar['composer/autoload_static.php']->getPathname());

			if (false === $content) {
				throw new RuntimeException('Could not read the content of "composer/autoload_classmap.php" file.');
			}

			/**
			 * @var string $autoloadStaticContent
			 */
			$autoloadStaticContent = \preg_replace(
				'/__DIR__\s*\.\s*\'\/..\/..\'\s*\.\s*/m',
				'PHAR_RUNNING . ',
				$content,
				-1,
				$replaced
			);

			if ($replaced > 0) {
				$autoloadStaticContent = \str_replace(
					'namespace Composer\Autoload;',
					'namespace Composer\Autoload;' . PHP_EOL . PHP_EOL . "define('PHAR_RUNNING',\\Phar::running(true).'/.mount');",
					$autoloadStaticContent
				);
			}

			$phar['composer/autoload_static.php'] = $autoloadStaticContent;
		}

		$phar->setStub(<<<'STUB'
<?php
declare(strict_types=1);

/**
 * Generated by vendor-compress.
 *
 * @version 2.0.0
 *
 * @see https://github.com/donatorsky/vendor-compress
 */

\Phar::interceptFileFuncs();
\Phar::mount(\Phar::running(true) . '/.mount/', __DIR__ . DIRECTORY_SEPARATOR);

return require_once 'phar://' . __FILE__ . DIRECTORY_SEPARATOR . 'autoload.php';

__HALT_COMPILER();
STUB
		);

		if (Phar::NONE !== $this->config->getFilesCompressionMethod()) {
			$TStart = \microtime(true);

			$phar->compressFiles($this->config->getFilesCompressionMethod());

			if ($this->config->isDebug()) {
				\printf("compressFiles(): %.6f s\n", \microtime(true) - $TStart);
			}
		}

		$phar->stopBuffering();

		if (Phar::NONE !== $this->config->getArchiveCompressionMethod()) {
			$TStart = \microtime(true);

			$phar->compress($this->config->getArchiveCompressionMethod());

			if ($this->config->isDebug()) {
				\printf("compress(): %.6f s\n", \microtime(true) - $TStart);
			}
		}

		if ($this->config->isDebug()) {
			\printf(
				"usage = %.2f MiB, usage(true) = %.2f MiB, peak_usage(true) = %.2f MiB, peak_usage(true) = %.2f MiB\n",
				\memory_get_usage() / 1024 ** 2,
				\memory_get_usage(true) / 1024 ** 2,
				\memory_get_peak_usage() / 1024 ** 2,
				\memory_get_peak_usage(true) / 1024 ** 2
			);
		}

		return $phar;
	}

	/**
	 * @param \Iterator $filesIterator
	 *
	 * @return \Generator
	 */
	private function getProcessedFilesIterator(Iterator $filesIterator): Generator {
		$fileProcessors = $this->config->getFileProcessors();
		$rootPathLength = \strlen($this->vendorDirectoryPath);

		/**
		 * @var \SplFileInfo $file
		 */
		foreach ($filesIterator as $absolutePath => $file) {
			$realPath = $file->getRealPath();
			//var_dump($file->getRealPath());

			if (false === $realPath) {
				throw new RuntimeException(\sprintf('Could not access "%s" file.', $absolutePath));
			}

			$fileContent = \file_get_contents($realPath);

			if (false === $fileContent) {
				throw new RuntimeException(\sprintf('Could not read the content of "%s" file.', $realPath));
			}

			/**
			 * @var \Donatorsky\VendorCompress\Contracts\FileFilterInterface    $fileFilter
			 * @var \Donatorsky\VendorCompress\Contracts\FileProcessorInterface $fileProcessor
			 */
			foreach ($fileProcessors as ['fileFilter' => $fileFilter, 'fileProcessor' => $fileProcessor]) {
				if ($fileFilter->matches($file)) {
					$fileContent = $fileProcessor->process($fileContent);
				}
			}

			yield \substr($absolutePath, $rootPathLength) => $fileContent;
		}
	}

	/**
	 * @return \RecursiveIteratorIterator<string, \SplFileInfo>
	 */
	private function getFilesIterator(): RecursiveIteratorIterator {
		$excluded = $this->config->getExcluded();
		$included = $this->config->getIncluded();

		return new RecursiveIteratorIterator(
			new RecursiveCallbackFilterIterator(
				new RecursiveDirectoryIterator(
					$this->vendorDirectoryPath,
					RecursiveDirectoryIterator::SKIP_DOTS
				),
				function (SplFileInfo $current) use ($excluded, $included): bool {
					foreach ($excluded as $fileFilter) {
						if ($fileFilter->matches($current)) {
							foreach ($included as $filter) {
								if ($filter->matches($current)) {
									return true;
								}
							}

							return false;
						}
					}

					return true;
				}
			),
			RecursiveIteratorIterator::LEAVES_ONLY
		);
	}

	/**
	 * @param array<string, \PharFileInfo>&\Phar $phar
	 * @param string                             $file
	 *
	 * @throws \RuntimeException
	 */
	private function updateBaseDir(Phar $phar, string $file): void {
		$content = \file_get_contents($phar[$file]->getPathname());

		if (false === $content) {
			throw new RuntimeException(\sprintf('Could not read the content of "%s" file.', $file));
		}

		$phar[$file] = \preg_replace(
			'/\$baseDir\s*=\s*dirname\(\$vendorDir\);/m',
			'$baseDir=\\\\Phar::running(true).\'/.mount\';',
			$content
		);
	}
}
